From 49cca70705ff9bb6fe6dc4c2fedcf12780865bfb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Cl=C3=A9ment=20B=C3=A9nier?= <clement.benier@openwide.fr>
Date: Wed, 9 Dec 2015 17:19:31 +0100
Subject: [PATCH 3/3] add hwcomposer
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Clément Bénier <clement.benier@openwide.fr>
---
 src/modules/ecore_evas/engines/fb/ecore_evas_fb.c  |   3 +-
 .../engines/wayland/ecore_evas_wayland_egl.c       |  42 ++++----
 src/modules/evas/engines/eglfs/evas_engine.c       |   9 +-
 src/modules/evas/engines/eglfs/evas_engine.h       |   5 +-
 src/modules/evas/engines/eglfs/evas_outbuf.c       | 119 ++++++++++++++++++++-
 5 files changed, 151 insertions(+), 27 deletions(-)

diff --git a/src/modules/ecore_evas/engines/fb/ecore_evas_fb.c b/src/modules/ecore_evas/engines/fb/ecore_evas_fb.c
index 586d797..5e47f34 100644
--- a/src/modules/ecore_evas/engines/fb/ecore_evas_fb.c
+++ b/src/modules/ecore_evas/engines/fb/ecore_evas_fb.c
@@ -740,7 +740,7 @@ ecore_evas_fb_new_internal(const char *disp_name, int rotation, int w, int h)
 			       (Ecore_Event_Mouse_Move_Cb)_ecore_evas_mouse_move_process,
 			       (Ecore_Event_Multi_Move_Cb)_ecore_evas_mouse_multi_move_process,
 			       (Ecore_Event_Multi_Down_Cb)_ecore_evas_mouse_multi_down_process,
-			       (Ecore_Event_Multi_Up_Cb)_ecore_evas_mouse_multi_up_process);              
+			       (Ecore_Event_Multi_Up_Cb)_ecore_evas_mouse_multi_up_process);
    evas_event_feed_mouse_in(ee->evas, (unsigned int)((unsigned long long)(ecore_time_get() * 1000.0) & 0xffffffff), NULL);
    return ee;
 }
@@ -757,6 +757,7 @@ ecore_evas_eglfs_new_internal(const char *disp_name, int rotation, int w, int h)
 
    if (!disp_name)
    disp_name = ecore_evas_default_display;
+   printf("disp_name:%s\n",disp_name);
 
    rmethod = evas_render_method_lookup("eglfs");
    if (!rmethod) return NULL;
diff --git a/src/modules/ecore_evas/engines/wayland/ecore_evas_wayland_egl.c b/src/modules/ecore_evas/engines/wayland/ecore_evas_wayland_egl.c
index 4871283..c5c1ef2 100644
--- a/src/modules/ecore_evas/engines/wayland/ecore_evas_wayland_egl.c
+++ b/src/modules/ecore_evas/engines/wayland/ecore_evas_wayland_egl.c
@@ -38,12 +38,12 @@ static void _ecore_evas_wl_alpha_set(Ecore_Evas *ee, int alpha);
 static void _ecore_evas_wl_transparent_set(Ecore_Evas *ee, int transparent);
 static void _ecore_evas_wl_rotation_set(Ecore_Evas *ee, int rotation, int resize);
 
-static Ecore_Evas_Engine_Func _ecore_wl_engine_func = 
+static Ecore_Evas_Engine_Func _ecore_wl_engine_func =
 {
    _ecore_evas_wl_common_free,
    _ecore_evas_wl_common_callback_resize_set,
    _ecore_evas_wl_common_callback_move_set,
-   NULL, 
+   NULL,
    NULL,
    _ecore_evas_wl_common_callback_delete_request_set,
    NULL,
@@ -189,7 +189,7 @@ ecore_evas_wayland_egl_new_internal(const char *disp_name, unsigned int parent,
    ee->prop.withdrawn = EINA_TRUE;
    ee->alpha = EINA_FALSE;
 
-   /* NB: Disabled for right now as it causes textgrid (terminology) 
+   /* NB: Disabled for right now as it causes textgrid (terminology)
     * to not draw text anymore */
    /* if (getenv("ECORE_EVAS_FORCE_SYNC_RENDER")) */
    ee->can_async_render = 0;
@@ -212,8 +212,8 @@ ecore_evas_wayland_egl_new_internal(const char *disp_name, unsigned int parent,
      }
 
    wdata->parent = p;
-   wdata->win = 
-     ecore_wl_window_new(p, x, y, w + fw, h + fh, 
+   wdata->win =
+     ecore_wl_window_new(p, x, y, w + fw, h + fh,
                          ECORE_WL_WINDOW_BUFFER_TYPE_EGL_WINDOW);
    ee->prop.window = ecore_wl_window_id_get(wdata->win);
 
@@ -224,7 +224,7 @@ ecore_evas_wayland_egl_new_internal(const char *disp_name, unsigned int parent,
    evas_output_viewport_set(ee->evas, 0, 0, ee->w + fw, ee->h + fh);
 
    if (ee->can_async_render)
-     evas_event_callback_add(ee->evas, EVAS_CALLBACK_RENDER_POST, 
+     evas_event_callback_add(ee->evas, EVAS_CALLBACK_RENDER_POST,
                              _ecore_evas_wl_common_render_updates, ee);
 
    evas_event_callback_add(ee->evas, EVAS_CALLBACK_RENDER_PRE,
@@ -247,7 +247,7 @@ ecore_evas_wayland_egl_new_internal(const char *disp_name, unsigned int parent,
              goto err;
           }
      }
-   else 
+   else
      {
         ERR("Failed to get Evas Engine Info for '%s'", ee->driver);
         goto err;
@@ -270,10 +270,10 @@ ecore_evas_wayland_egl_new_internal(const char *disp_name, unsigned int parent,
    _ecore_evas_register(ee);
    ecore_evas_input_event_register(ee);
 
-   ecore_event_window_register(ee->prop.window, ee, ee->evas, 
-                               (Ecore_Event_Mouse_Move_Cb)_ecore_evas_mouse_move_process, 
-                               (Ecore_Event_Multi_Move_Cb)_ecore_evas_mouse_multi_move_process, 
-                               (Ecore_Event_Multi_Down_Cb)_ecore_evas_mouse_multi_down_process, 
+   ecore_event_window_register(ee->prop.window, ee, ee->evas,
+                               (Ecore_Event_Mouse_Move_Cb)_ecore_evas_mouse_move_process,
+                               (Ecore_Event_Multi_Move_Cb)_ecore_evas_mouse_multi_move_process,
+                               (Ecore_Event_Multi_Down_Cb)_ecore_evas_mouse_multi_down_process,
                                (Ecore_Event_Multi_Up_Cb)_ecore_evas_mouse_multi_up_process);
 
    return ee;
@@ -287,7 +287,7 @@ ecore_evas_wayland_egl_new_internal(const char *disp_name, unsigned int parent,
    return NULL;
 }
 
-static void 
+static void
 _ecore_evas_wl_move_resize(Ecore_Evas *ee, int x, int y, int w, int h)
 {
    LOGFN(__FILE__, __LINE__, __FUNCTION__);
@@ -319,7 +319,7 @@ _ecore_evas_wl_rotation_set(Ecore_Evas *ee, int rotation, int resize)
      ERR("evas_engine_info_set() for engine '%s' failed.", ee->driver);
 }
 
-static void 
+static void
 _ecore_evas_wl_show(Ecore_Evas *ee)
 {
    Evas_Engine_Info_Wayland_Egl *einfo;
@@ -369,7 +369,7 @@ _ecore_evas_wl_show(Ecore_Evas *ee)
    if (ee->func.fn_show) ee->func.fn_show(ee);
 }
 
-static void 
+static void
 _ecore_evas_wl_hide(Ecore_Evas *ee)
 {
    Ecore_Evas_Engine_Wl_Data *wdata;
@@ -389,7 +389,7 @@ _ecore_evas_wl_hide(Ecore_Evas *ee)
         evas_engine_info_set(ee->evas, (Evas_Engine_Info *)einfo);
      }
 
-   if (wdata->win) 
+   if (wdata->win)
      ecore_wl_window_hide(wdata->win);
 
    if (ee->prop.override)
@@ -406,7 +406,7 @@ _ecore_evas_wl_hide(Ecore_Evas *ee)
    if (ee->func.fn_hide) ee->func.fn_hide(ee);
 }
 
-static void 
+static void
 _ecore_evas_wayland_egl_alpha_do(Ecore_Evas *ee, int alpha)
 {
    Evas_Engine_Info_Wayland_Egl *einfo;
@@ -446,7 +446,7 @@ _ecore_evas_wl_alpha_set(Ecore_Evas *ee, int alpha)
    _ecore_evas_wayland_egl_alpha_do(ee, alpha);
 }
 
-static void 
+static void
 _ecore_evas_wayland_egl_transparent_do(Ecore_Evas *ee, int transparent)
 {
    Evas_Engine_Info_Wayland_Egl *einfo;
@@ -474,7 +474,7 @@ _ecore_evas_wayland_egl_transparent_do(Ecore_Evas *ee, int transparent)
      }
 }
 
-static void 
+static void
 _ecore_evas_wl_transparent_set(Ecore_Evas *ee, int transparent)
 {
    if (ee->in_async_render)
@@ -487,7 +487,7 @@ _ecore_evas_wl_transparent_set(Ecore_Evas *ee, int transparent)
    _ecore_evas_wayland_egl_transparent_do(ee, transparent);
 }
 
-void 
+void
 _ecore_evas_wayland_egl_resize(Ecore_Evas *ee, int location)
 {
    Ecore_Evas_Engine_Wl_Data *wdata;
@@ -496,7 +496,7 @@ _ecore_evas_wayland_egl_resize(Ecore_Evas *ee, int location)
 
    if (!ee) return;
    wdata = ee->engine.data;
-   if (wdata->win) 
+   if (wdata->win)
      {
         _ecore_evas_wayland_egl_resize_edge_set(ee, location);
 
@@ -507,7 +507,7 @@ _ecore_evas_wayland_egl_resize(Ecore_Evas *ee, int location)
      }
 }
 
-void 
+void
 _ecore_evas_wayland_egl_resize_edge_set(Ecore_Evas *ee, int edge)
 {
    Evas_Engine_Info_Wayland_Egl *einfo;
diff --git a/src/modules/evas/engines/eglfs/evas_engine.c b/src/modules/evas/engines/eglfs/evas_engine.c
index 7c59f6f..36ee69a 100644
--- a/src/modules/evas/engines/eglfs/evas_engine.c
+++ b/src/modules/evas/engines/eglfs/evas_engine.c
@@ -331,6 +331,7 @@ evgl_eng_make_current(void *data, void *surface, void *context, int flush)
 static void *
 evgl_eng_native_window_create(void *data)
 {
+    printf("native_window_create\n");
    Render_Engine *re;
    Evas_Engine_Info_Eglfs *info;
 
@@ -348,7 +349,11 @@ evgl_eng_native_window_create(void *data)
         return NULL;
      }
 
-   return NULL;
+   printf("call hwcomposer\n");
+   EGLNativeWindowType win;
+   win = create_hwcomposernativewindow();
+   printf("called hwcomposer -> win:%p\n",(void *)win);
+   return (void *)win;
 }
 
 static int
@@ -796,7 +801,7 @@ eng_setup(Evas *evas, void *in)
                                                 &evgl_funcs, ob->w, ob->h))
           {
              /* free outbuf */
-   
+
              evas_outbuf_free(ob);
              free(re);
              return 0;
diff --git a/src/modules/evas/engines/eglfs/evas_engine.h b/src/modules/evas/engines/eglfs/evas_engine.h
index 461f330..12aa07f 100644
--- a/src/modules/evas/engines/eglfs/evas_engine.h
+++ b/src/modules/evas/engines/eglfs/evas_engine.h
@@ -74,7 +74,7 @@ struct _Outbuf
    unsigned int rotation, depth;
    Render_Engine_Swap_Mode swap_mode;
 
-   struct 
+   struct
      {
         EGLContext context[1];
         EGLSurface surface[1];
@@ -82,7 +82,7 @@ struct _Outbuf
         EGLDisplay disp;
      } egl;
 
-   struct 
+   struct
      {
         int prev_age, frame_cnt;
         int curr, last, num;
@@ -113,6 +113,7 @@ Evas_Engine_GL_Context* evas_outbuf_gl_context_get(Outbuf *ob);
 void *evas_outbuf_egl_display_get(Outbuf *ob);
 Context_3D *evas_outbuf_gl_context_new(Outbuf *ob);
 void evas_outbuf_gl_context_use(Context_3D *ctx);
+EGLNativeWindowType create_hwcomposernativewindow(void);
 
 static inline Eina_Bool
 _re_wincheck(Outbuf *ob)
diff --git a/src/modules/evas/engines/eglfs/evas_outbuf.c b/src/modules/evas/engines/eglfs/evas_outbuf.c
index d2ee1e5..9036e8f 100644
--- a/src/modules/evas/engines/eglfs/evas_outbuf.c
+++ b/src/modules/evas/engines/eglfs/evas_outbuf.c
@@ -1,5 +1,119 @@
 #include "evas_engine.h"
 
+#include <hybris/hwcomposerwindow/hwcomposer.h>
+#include <hardware/hwcomposer.h>
+#include <hardware/hardware.h>
+#include <android-config.h>
+
+static hwc_layer_1_t *fblayer;
+static hwc_composer_device_1_t *hwcDevicePtr;
+static hwc_display_contents_1_t **mList;
+
+
+void present(void *user_data, struct ANativeWindow *window,
+	                                   struct ANativeWindowBuffer *buffer)
+{
+
+	int oldretire = mList[0]->retireFenceFd;
+	mList[0]->retireFenceFd = -1;
+	fblayer->handle = buffer->handle;
+	fblayer->acquireFenceFd = HWCNativeBufferGetFence(buffer);
+	fblayer->releaseFenceFd = -1;
+	int err = hwcDevicePtr->prepare(hwcDevicePtr, HWC_NUM_DISPLAY_TYPES, mList);
+	//assert(err == 0);
+
+	err = hwcDevicePtr->set(hwcDevicePtr, HWC_NUM_DISPLAY_TYPES, mList);
+	//assert(err == 0);
+	HWCNativeBufferSetFence(buffer, fblayer->releaseFenceFd);
+
+	if (oldretire != -1)
+	{
+		sync_wait(oldretire, -1);
+		close(oldretire);
+	}
+}
+
+
+EGLNativeWindowType create_hwcomposernativewindow(void)
+{
+	int err;
+	hw_module_t *hwcModule = 0;
+	hwcDevicePtr = 0;
+
+	err = hw_get_module(HWC_HARDWARE_MODULE_ID, (const hw_module_t **) &hwcModule);
+	//assert(err == 0);
+
+	err = hwc_open_1(hwcModule, &hwcDevicePtr);
+	//assert(err == 0);
+
+	hwcDevicePtr->blank(hwcDevicePtr, 0, 0);
+
+	uint32_t configs[5];
+	size_t numConfigs = 5;
+
+	err = hwcDevicePtr->getDisplayConfigs(hwcDevicePtr, 0, configs, &numConfigs);
+	//assert (err == 0);
+
+	int32_t attr_values[2];
+	uint32_t attributes[] = { HWC_DISPLAY_WIDTH, HWC_DISPLAY_HEIGHT, HWC_DISPLAY_NO_ATTRIBUTE };
+
+	hwcDevicePtr->getDisplayAttributes(hwcDevicePtr, 0,
+			configs[0], attributes, attr_values);
+
+	printf("width: %i height: %i\n", attr_values[0], attr_values[1]);
+
+	size_t size = sizeof(hwc_display_contents_1_t) + 2 * sizeof(hwc_layer_1_t);
+	hwc_display_contents_1_t *list = (hwc_display_contents_1_t *) malloc(size);
+	mList = (hwc_display_contents_1_t **) malloc(HWC_NUM_DISPLAY_TYPES * sizeof(hwc_display_contents_1_t *));
+	const hwc_rect_t r = { 0, 0, attr_values[0], attr_values[1] };
+
+	int counter = 0;
+	for (; counter < HWC_NUM_DISPLAY_TYPES; counter++)
+		mList[counter] = NULL;
+	// Assign buffer only to the first item, otherwise you get tearing
+	// if passed the same to multiple places
+	mList[0] = list;
+
+	fblayer = &list->hwLayers[0];
+	memset(fblayer, 0, sizeof(hwc_layer_1_t));
+	fblayer->compositionType = HWC_FRAMEBUFFER;
+	fblayer->hints = 0;
+	fblayer->flags = 0;
+	fblayer->handle = 0;
+	fblayer->transform = 0;
+	fblayer->blending = HWC_BLENDING_NONE;
+	fblayer->sourceCrop = r;
+	fblayer->displayFrame = r;
+	fblayer->visibleRegionScreen.numRects = 1;
+	fblayer->visibleRegionScreen.rects = &fblayer->displayFrame;
+	fblayer->acquireFenceFd = -1;
+	fblayer->releaseFenceFd = -1;
+	fblayer = &list->hwLayers[1];
+	memset(fblayer, 0, sizeof(hwc_layer_1_t));
+	fblayer->compositionType = HWC_FRAMEBUFFER_TARGET;
+	fblayer->hints = 0;
+	fblayer->flags = 0;
+	fblayer->handle = 0;
+	fblayer->transform = 0;
+	fblayer->blending = HWC_BLENDING_NONE;
+	fblayer->sourceCrop = r;
+	fblayer->displayFrame = r;
+	fblayer->visibleRegionScreen.numRects = 1;
+	fblayer->visibleRegionScreen.rects = &fblayer->displayFrame;
+	fblayer->acquireFenceFd = -1;
+	fblayer->releaseFenceFd = -1;
+
+	list->retireFenceFd = -1;
+	list->flags = HWC_GEOMETRY_CHANGED;
+	list->numHwLayers = 2;
+
+	EGLNativeWindowType win = NULL;
+   	win = (EGLNativeWindowType)HWCNativeWindowCreate(attr_values[0], attr_values[1], HAL_PIXEL_FORMAT_RGBA_8888, present, NULL);
+    printf("\n\nhwcomposer -> win:%p\n\n\n\n\n",win);
+    return win;
+}
+
+
 /* local variables */
 static Outbuf *_evas_eglfs_window = NULL;
 static EGLContext context = EGL_NO_CONTEXT;
@@ -102,10 +216,13 @@ _evas_outbuf_egl_setup(Outbuf *ob)
 
    // First is always best...
    ob->egl.config = cfgs[0];
+   printf("hello\n");
+
 
+   EGLNativeWindowType win = create_hwcomposernativewindow();
    ob->egl.surface[0] =
      eglCreateWindowSurface(ob->egl.disp, ob->egl.config,
-                            (EGLNativeWindowType)NULL, NULL);
+                            (EGLNativeWindowType)win, NULL);
    if (ob->egl.surface[0] == EGL_NO_SURFACE)
      {
         ERR("eglCreateWindowSurface() fail for %p. code=%#x",
-- 
2.6.2

